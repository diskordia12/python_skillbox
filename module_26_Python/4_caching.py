"""
Задача 4. Кеширование для ускорения вычислений
Вы разрабатываете программу для оптимизации вычислений чисел Фибоначчи.
Числа Фибоначчи вычисляются рекурсивной функцией,
каждое число равно сумме двух предыдущих чисел.
Однако вы заметили, что при больших значениях чисел Фибоначчи вычисления занимают
значительное время, так как многие значения вычисляются повторно.
Вам поручили создать декоратор, который кеширует результаты вызова функции
и позволяет избежать повторных вычислений для одних и тех же аргументов.

Для начала работы у вас есть такой код:

def fibonacci(number):
    if number <= 1:
        return number
    return fibonacci(number - 1) + fibonacci(number - 2)

# Вычисление числа Фибоначчи с использованием кеширования
print(fibonacci(10))  # Результат будет кеширован

# Повторное вычисление числа Фибоначчи с теми же аргументами
print(fibonacci(10))  # Результат будет взят из кеша

# Вычисление числа Фибоначчи с другим аргументом
print(fibonacci(5))  # Результат будет вычислен и закеширован

Создайте декоратор, который кеширует (сохраняет для дальнейшего использования)
результаты вызова функции и, при повторном вызове с теми же аргументами,
возвращает сохранённый результат.
Примените его к рекурсивной функции вычисления чисел Фибоначчи.
В итоге декоратор должен проверять аргументы, с которыми вызывается функция, и,
если такие аргументы уже использовались, возвращать сохранённый результат вместо запуска расчёта.

Советы:
- Для хранения результатов удобно использовать словарь,
    так как поиск элементов внутри словаря будет иметь сложность, равную в среднем O(1).
- При этом не стоит хранить все вычисления в одном словаре,
    созданном снаружи функций (в глобальной области видимости).
    Лучше создавать отдельные словари для каждой декорируемой функции.
"""
from typing import Callable
from functools import wraps


def cashing(func: Callable) -> Callable:
    cache = dict()

    @wraps(func)
    def wrapped_func(number: int) -> int:
        """

        :param number: The integer for which you want to get the result
        :return:  The result of executing the function.
                If the function has already been called with this argument,
                the result is taken from the cache
        """
        if number not in cache:
            cache[number] = func(number)
        return cache[number]
    return wrapped_func


@cashing
def fibonacci(number):
    if number <= 1:
        return number
    return fibonacci(number - 1) + fibonacci(number - 2)


# Вычисление числа Фибоначчи с использованием кеширования
print(fibonacci(10))  # Результат будет кеширован

# Повторное вычисление числа Фибоначчи с теми же аргументами
print(fibonacci(10))  # Результат будет взят из кеша

# Вычисление числа Фибоначчи с другим аргументом
print(fibonacci(5))  # Результат будет вычислен и закеширован