"""
Задача 5. Список списков — 2
Вы уже работали с многомерными списками и решали задачи, где с помощью list comprehensions
«выпрямляли» многомерные списки в один.
Это не получится, если списков неограниченное количество и у элементов разные уровни вложенности.

Дан такой список:
nice_list = [1, 2, [3, 4], [[5, 6, 7], [8, 9, 10]], [[11, 12, 13], [14, 15], [16, 17, 18]]]

Напишите рекурсивную функцию, которая раскрывает все вложенные списки,
то есть оставляет только внешний список.
Ответ: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]

Функция должна получать список и возвращать его раскрытую версию
(не нужно добавлять элементы в список, записанный в глобальную переменную, созданную снаружи функции).

Подсказка
Можно возвращать списки и срезы списков.
"""


def open_list(seq: list) -> list:
    if not seq:
        return seq

    if isinstance(seq[0], list):
        return open_list(seq[0]) + open_list(seq[1:])

    return seq[:1] + open_list(seq[1:])


nice_list = [1, 2, [3, 4], [[5, 6, 7], [8, 9, 10]], [[11, 12, 13], [14, 15], [16, 17, 18]]]
nice_list_2 = ([1, 2])
print(open_list(nice_list))

****************************************
"""
Задача 4. Продвинутая функция sum
Как вы знаете, в Python есть полезная функция sum,
которая умеет находить сумму элементов списков.
Иногда базовых возможностей функций не хватает для работы и приходится их усовершенствовать.
Напишите свою функцию sum, которая должна быть более гибкой, чем стандартная.
Она должна уметь складывать числа:
- из спска списков,
- набора параметров.
Основной код оставьте пустым или закомментированным (используйте его только для тестирования).
Примеры вызовов функции
> sum([[1, 2, [3]], [1], 3])
> Ответ в консоли: 10

> sum(1, 2, 3, 4, 5)
> Ответ в консоли: 15
"""


def my_sum(*args, summ=0) -> int:
    for elem in args:
        if isinstance(elem, int):
            summ += elem
        else:
            summ += my_sum(*elem)
    return summ


def my_sum_2(elem, *args):
    if elem is None:
        return 0
    if isinstance(elem, int):
        return elem + my_sum(*args)
    if isinstance(elem, list) or isinstance(elem, tuple):
        return my_sum(*elem) + my_sum(*args)
    raise TypeError('Wrong element type')


first_list = [[1, 2, [3]], [1], 3]
second_list = [1, 2, 3, 4, 5]
print(my_sum(first_list))
print(my_sum(second_list))
print(my_sum(1, 2, 4, 5))
print(my_sum_2(first_list))
print(my_sum_2(second_list))
print(my_sum_2(1, 2, 4, 5))

****************************************
"""
Задача 6. Быстрая сортировка
Реализуйте алгоритм быстрой сортировки (её называют сортировкой Хоара).

За один шаг алгоритма выполните следующие действия:
1. Выберите один элемент списка (его иногда называют опорным элементом).
    Сделать это можно разными способами, но важно придерживаться одного принципа.
    В нашем случае опорным элементом всегда будет крайний правый (например, в списке [1, 2, 3] это 3).
2. Разбейте текущий список на три части: элементы меньше опорного, равные опорному и больше опорного.
    В списке [5, 8, 9, 4, 2, 9, 1, 8] опорным элементом будет число 8 (крайнее правое),
    а получить надо три списка:
    [5, 4, 2, 1];
    [8, 8];
    [9, 9].
3. Для списка с элементами меньше опорного ([5, 4, 2, 1]) и
    списка с элементами больше опорного ([9, 9]) выполните те же шаги заново — запустите рекурсию.
    результат_1 = рекурсия([5, 4, 2, 1]).
    результат_2 = [8, 8].
    результат_3 = рекурсия([9, 9]).
4. Сложите результаты вызова рекурсий и получите отсортированный список:
    отсортированный_список = результат_1 + результат_2 + результат_3.
    Пример с разбором алгоритма выше (как сработала рекурсия)

С [9, 9] всё просто. Элементов меньше или больше опорного нет, поэтому рекурсия не пойдёт глубже,
а вызов рекурсии по списку [9, 9] быстро завершится и вернёт этот же список
(его и не нужно было сортировать).

С [5, 4, 2, 1] рекурсия пойдёт вглубь:
Первый шаг— [5, 4, 2, 1]:
    опорным элементом выбирается число 1;
    меньше 1 элементов нет (значит, рекурсия по ним продолжаться не будет);
    помимо опорного элемента, других равных нет, получаем список [1];
    больше 1 все остальные элементы [5, 4, 2] — с этим списком будет вызвана рекурсия.
Второй шаг— [5, 4, 2]:
    опорный элемент — 2;
    меньше опорного — [];
    равные опорному — [2];
    больше опорного — [5, 4].
Третий шаг— [5, 4]:
    опорный элемент — 4;
    меньше — [];
    равны — [4];
    больше — [5].
Четвёртый шаг — [5]:
    меньше — [];
    равны — [5];
    больше — [].
Тут вызовы завершаются, мы соединяем списки и возвращаем список [5] на уровень выше
(в вызов с числами [5, 4]).

Там мы соединяем списки [] + [4] + [5] и получаем [4, 5].
Этот список возвращаем ещё на уровень выше (в вызов с числами [5, 4, 2]).

Опять складываем списки:
[ ] + [2] + [4, 5] = [2, 4, 5].

Этот список возвращаем в вызов на уровень выше (тот, который был запущен с [5, 4, 2, 1]).

Складываем списки:
[ ] + [1] + [2, 4, 5] = [1, 2, 4, 5].

Возвращаем [1, 2, 4, 5] в самый первый вызов, где мы выполняли следующие вызовы:
результат_1 = рекурсия([5, 4, 2, 1]).
результат_2 = [8, 8].
результат_3 = рекурсия([9, 9]).

В итоге после выполнения всех рекурсий получаем:
результат_1 = [1, 2, 4, 5].
результат_2 = [8, 8].
результат_3 = [9, 9].

Складываем все списки:
[1, 2, 4, 5] + [8, 8] + [9, 9] = [1, 2, 4, 5, 8, 8, 9, 9].
Этот полный список возвращается наружу — туда, где функция была вызвана изначально.

Напишите функцию, которая реализует этот алгоритм.
Для удобства добавьте вспомогательную функцию,
пусть она принимает на вход список, а возвращает три списка
(с элементами меньше, равными и больше опорного).

Пример работы такой функции:
числа = [4, 9, 2, 7, 5]
вспомогательная_функция(числа) → [4, 2], [5], [9, 7]

Эту функцию можно будет использовать в основной-рекурсивной,
чтобы код основной функции стал проще и понятнее.
"""


def divide_into_three_lists(lst: list) -> tuple:
    based_num = lst[-1]
    less = list()
    equal = list()
    greater = list()
    for num in lst:
        if num < based_num:
            less.append(num)
        elif num == based_num:
            equal.append(num)
        else:
            greater.append(num)
    return less, equal, greater


def quick_sort(seq: list) -> list:
    if not seq:
        return seq

    low_seq, mid_seq, above_seq = divide_into_three_lists(seq)
    low_result = quick_sort(low_seq)
    mid_result = mid_seq
    above_result = quick_sort(above_seq)
    return low_result + mid_result + above_result


unsorted_sequence = [5, 8, 9, 4, 2, 9, 1, 8]
print(quick_sort(unsorted_sequence))

****************************************
"""
Задача 2. Поиск элемента — 2
Пользователь вводит искомый ключ.
Если он хочет, то может ввести максимальную глубину — уровень,
до которого будет просматриваться структура.

Напишите функцию, которая находит заданный пользователем ключ в словаре и
выдаёт значение этого ключа на экран.
По умолчанию уровень не задан. В качестве примера можно использовать такой словарь:

site = {
'html': {
'head': {
'title': 'Мой сайт'
},
'body': {
'h2': 'Здесь будет мой заголовок',
'div': 'Тут, наверное, какой-то блок',
'p': 'А вот здесь новый абзац'
}
}
}

Пример 1
> Введите искомый ключ: head
> Хотите ввести максимальную глубину? Y/N: n
> Значение ключа: {'title': 'Мой сайт'}

Пример 2
> Введите искомый ключ: head
> Хотите ввести максимальную глубину? Y/N: y
> Введите максимальную глубину: 1
> Значение ключа: None
"""


def search_element(struct: dict, key: str, deep=None) -> str:
    result = None
    if deep == 0:
        return result

    if key in struct:
        return struct[key]

    for sub_struct in struct.values():
        if not isinstance(sub_struct, dict):
            continue
        result = search_element(sub_struct, key, deep - 1 if deep else None)
        if result:
            break

    return result


site = {
    'html': {
        'head': {
            'title': 'Мой сайт'
        },
        'body': {
            'h2': 'Здесь будет мой заголовок',
            'div': 'Тут, наверное, какой-то блок',
            'p': 'А вот здесь новый абзац'
        }
    }
}


user_key = input('Enter a key for search: ')
user_deep = None
flag_deep = input('Do you want to enter max deep? Y/N ').lower()
if flag_deep == 'y':
    user_deep = int(input('Enter max deep: '))

value = search_element(site, user_key, deep=user_deep)

if value:
    print(f'Result: {value}')
else:
    print('There is no such key')

****************************************
"""
Задача 3. Глубокое копирование
Вы сделали для заказчика структуру сайта по продаже телефонов:

site = {
'html': {
'head': {
'title': 'Куплю/продам телефон недорого'
},
'body': {
'h2': 'У нас самая низкая цена на iPhone',
'div': 'Купить',
'p': ‘Продать'
}
}
}
Заказчик рассказал своим коллегам на рынке, и они захотели такой же сайт для своих товаров.
Вы посчитали, что это лёгкая задача, и быстро принялись за работу.

Напишите программу, которая запрашивает у клиента количество сайтов,
затем названия продуктов, а после каждого запроса выводит на экран активные сайты.

Условия:
- учтите, что функция должна уметь работать с разными сайтами
  (иначе вам придётся переделывать программу под каждого заказчика заново);
- вы должны получить список, хранящий сайты для разных продуктов
  (а значит, для каждого продукта нужно будет первым делом выполнить глубокое копирование сайта).

Подсказка
Чтобы заменить элемент, его нужно найти.
Для поиска можете использовать рекурсивный алгоритм из задачи по поиску элемента.

Пример вывода
Сколько сайтов: 2

Введите название продукта для нового сайта: iPhone
Сайт для iPhone:
site = {
'html': {
'head': {
'title': 'Куплю/продам iPhone недорого'
},
'body': {
'h2': 'У нас самая низкая цена на iPhone',
'div': 'Купить',
'p': ‘Продать'
}
}
}
Введите название продукта для нового сайта: Samsung

Сайт для iPhone:
site = {
'html': {
'head': {
'title': 'Куплю/продам iPhone недорого'
},
'body': {
'h2': 'У нас самая низкая цена на iPhone',
'div': 'Купить',
'p': ‘Продать'
}
}
}
Сайт для Samsung:

site = {
'html': {
'head': {
'title': 'Куплю/продам Samsung недорого'
},
'body': {
'h2': 'У нас самая низкая цена на Samsung',
'div': 'Купить',
'p': ‘Продать'
}
}
}
Обратите внимание, что на первой итерации выводится только один сайт (для iPhone),
а на второй итерации — оба сайта (и для iPhone и для Samsung).
Чтобы это реализовать, нужно сохранять сайты в списке и каждый раз печатать все его элементы.
"""
import copy

def add_new_item_name(data: dict, item: str) -> dict:
    data['html']['head']['title'] = data['html']['head']['title'].format(phone=item)
    data['html']['body']['h2'] = data['html']['body']['h2'].format(phone=item)
    return data





site_template = {
    'html': {
        'head': {
            'title': 'Куплю/продам {phone} недорого'
        },
        'body': {
            'h2': 'У нас самая низкая цена на {phone}',
            'div': 'Купить',
            'p': 'Продать'
        }
    }
}

amount_of_sites = int(input('Enter amount of sites: '))
sites = list()

for _ in range(amount_of_sites):
    item_name = input('Name of new item for new site: ')
    new_site = copy.deepcopy(site_template)
    sites.append(add_new_item_name(new_site, item_name))
    for site in sites:
        for struc, sub_struc in site.items():
            print(f'{struc}: {sub_struc}')



****************************************
"""
Задача 1. Challenge
Обычно программисты любят, когда всё просто и понятно.
Но Антон не из таких. Он любит устраивать себе челлендж,
развиваться и сразу применять на практике то, что только что узнал.
И в этот раз он подумал реализовать подсчёт факториала без использования циклов.
Напишите функцию, которая считает факториал числа с помощью рекурсии.
Кстати, в Python есть ограничение на количество рекурсивных вызовов.
Попробуйте передать своей функции, например, число 1000 и посмотрите, что будет.
"""

# def factorial(num: int) -> int:
#     if num == 1:
#         return num
#     return num * factorial(num - 1)
#
#
# print(factorial(3))
# print(factorial(5))


"""
Задача 2. Степень числа
На одном из форумов, посвящённых программированию,
пользователь выложил такой код для расчёта степени числа без использования циклов,
** и функции math.pow():

def power(a, n):
    return a * power(a, n)
 
float_num = float(input('Введите вещественное число: '))
int_num = int(input('Введите степень числа: '))
print(float_num, '**', int_num, '=', power(float_num, int_num))
 
Другие пользователи отметили, что это решение нерабочее и в нём есть ошибки.
Исправьте это решение, не используя циклы, возведение в степень через ** и функцию math.pow()

Правильный результат:
> Введите вещественное число: 1.5
> Введите степень числа: 5
> 1.5 ** 5 = 7.59375

2**3 = 2 * 2**2
2**2 = 2 ** 2**1
"""

# def power(a, n):
#     if n == 1:
#         return a
#     return a * power(a, n - 1)
#
#
# user_num = float(input('Введите вещественное число: '))
# power_of_num = int(input('Введите степень числа: '))
# print(f'{user_num} ** {power_of_num} = {power(user_num, power_of_num)} ')

"""
Задача 3. Поиск элемента
Когда мы работаем с большой многоуровневой структурой, нам нередко необходимо пройтись по ней
и найти нужный элемент. Для этого в программировании используются специальные алгоритмы поиска.
Напишите функцию, которая находит заданный пользователем ключ в словаре
и выдаёт значение этого ключа на экран. В качестве примера можно использовать такой словарь:

site = {
    'html': {
        'head': {
            'title': 'Мой сайт'
        },
        'body': {
            'h2': 'Здесь будет мой заголовок',
            'div': 'Тут, наверное, какой-то блок',
            'p': 'А вот здесь новый абзац'
        }
    }
}

Пример 1:
Искомый ключ: h2
Значение: Здесь будет мой заголовок

Пример 2:
Искомый ключ: abc
Такого ключа в структуре сайта нет.
"""
#
#
# site = {
#     'html': {
#         'head': {
#             'title': 'Мой сайт'
#         },
#         'body': {
#             'h2': 'Здесь будет мой заголовок',
#             'div': 'Тут, наверное, какой-то блок',
#             'p': 'А вот здесь новый абзац'
#         }
#     }
# }
#
#
# def search_element(struct: dict, key: str) -> str:
#     result = None
#     if key in struct:
#         return struct[key]
#
#     for sub_struct in struct.values():
#         if isinstance(sub_struct, dict):
#             result = search_element(sub_struct, key)
#             if result:
#                 return result
#
#     return result
#
#
# user_key = input('Enter a key for search: ')
# value = search_element(site, user_key)
# if value:
#     print(f'Result: {value}')
# else:
#     print('There are not such a key')


"""
Задача 1. Ошибка
В одном проекте на 10 000 строк кода произошла критическая ошибка.
Хорошо, что старший разработчик быстро её нашёл и исправил.
Он решил проверить, смогли бы вы её исправить, если бы его не было на месте.
Поэтому он написал для вас код с аналогичной ошибкой:

import random
 
def change_dict(dct):
    num = random.randint(1, 100)
    for i_key, i_value in dct.items():
        if isinstance(i_value, list):
            i_value.append(num)
        if isinstance(i_value, dict):
            i_value[num] = i_key
        if isinstance(i_value, set):
            i_value.add(num)
 
 
nums_list = [1, 2, 3]
some_dict = {1: 'text', 2: 'another text'}
uniq_nums = {1, 2, 3}
common_dict = {1: nums_list, 2: some_dict, 3: uniq_nums, 4: (10, 20, 30)}
 
change_dict(common_dict)
print(common_dict)
 

Суть кода в том, что у вас есть общий словарь из нескольких ключей,
значения которых равны ранее объявленным переменным.
Затем вызывается функция, которая должна изменять значения словаря,
добавляя к значениям случайное число, в зависимости от типа данных.
Но при этом меняются и ранее объявленные переменные.
Исправьте эту ошибку и убедитесь, что nums_list, some_dict и uniq_nums не меняются.

Подсказка. Для копирования объектов есть несколько способов:

Встроенный метод copy. Пример для словаря.
Встроенный в Python модуль copy и функции copy.copy() и copy.deepcopy().
"""
#
# import random
# import copy
#
#
# def change_dict(dct: dict):
#     num = random.randint(1, 100)
#     for i_key, i_value in dct.items():
#         if isinstance(i_value, list):
#             i_value.append(num)
#         if isinstance(i_value, dict):
#             i_value[num] = i_key
#         if isinstance(i_value, set):
#             i_value.add(num)
#
#
# nums_list = [1, 2, 3]
# some_dict = {1: 'text', 2: 'another text'}
# uniq_nums = {1, 2, 3}
# common_dict = {1: nums_list, 2: some_dict, 3: uniq_nums, 4: (10, 20, 30)}
# common_dict_copy = copy.deepcopy(common_dict)
#
# change_dict(common_dict_copy)
# print(common_dict_copy)
# print(f'nums list: {nums_list}')
# print(f'some dict: {some_dict}')
# print(f'uniq nums: {uniq_nums}')


"""
Задача 2. Непонятно!
Друг никак не может понять эту тему с изменяемыми и неизменяемыми типами, ссылками,
объектами и их id. Видя, как он мучается, вы решили помочь ему и объяснить эту тему наглядно.
Пользователь вводит любой объект. Напишите программу, которая выводит на экран тип введённых данных,
информацию о его изменяемости, а также id этого объекта.

Помните, что через input можно получить только строку,
что бы вы ни вводили.
В данном случае ввод можно выполнить вручную, просто вписав нужный объект в переменную,
без использования функции input.

Пример 1:
Введите данные: привет
Тип данных: str (строка)
Неизменяемый (immutable)
Id объекта: 1705156583984

Пример 2:
Введите данные: {‘a’: 10, ‘b’: 20}
Тип данных: dict (словарь)
Изменяемый (mutable)
Id объекта: 1705205308536
"""
#
# my_text = 'geralt'
# my_number = 34
# my_list = [1, 2, 3]
# my_dict = {1: 'no', 2: 'yes'}
# my_set = {2, 4, 5}
# my_tuple = (2, 1, 4)
#
#
# data_names_dict = {
#     "<class 'str'>": "строка",
#     "<class 'dict'>": "словарь",
#     "<class 'list'>": "список",
#     "<class 'set'>": "множество"
# }
#
# mutable_check_helper = {
#     "mutable": ("словарь", "список", "множество")
# }
#
#
# def check_info(data):
#     type_of_data = type(data)
#     name_of_data = ""
#     if str(type_of_data) in data_names_dict:
#         name_of_data = data_names_dict[str(type_of_data)]
#
#     if name_of_data in mutable_check_helper["mutable"]:
#         property_of_data = "Изменяемый (mutable)"
#     else:
#         property_of_data = "Неизменяемый (immutable)"
#
#     print(f"Тип данных: {type_of_data} ({name_of_data})")
#     print(property_of_data)
#     print("Id объекта:", id(data))
#
#
# data_in = "привет"
# check_info(data_in)
#
# check_info(my_number)


"""
Задача 1. Работа с файлом
Вы пишете небольшое приложение для работы с файлами.
Реализуйте функцию, которая может принимать на вход три аргумента:
вопрос пользователю (на который нужно ответить да или нет),
сообщение о неправильном вводе и количество попыток.
Вопрос — обязательный позиционный аргумент, остальные — со значениями по умолчанию.
При корректном ответе функция может возвращать что угодно — например,
число 1 при ответе «да» или 0 при ответе «нет».
В основной программе вызовите функцию минимум три раза: только с вопросом, с вопросом и сообщением
об ошибке, с вопросом и количеством попыток.

Пример работы программы:
Вы действительно хотите выйти? что
Неверный ввод. Пожалуйста, введите 'да' или 'нет'.
Осталось попыток: 3
Вы действительно хотите выйти? да

Удалить файл? не знаю
Так удалить или нет? 
Осталось попыток: 3

Удалить файл? нет

Записать файл? ага
Неверный ввод. Пожалуйста, введите 'да' или 'нет'.
Осталось попыток: 1
Записать файл? да
"""

#
# def write_down(question: str,
#                complaint: str = 'Incorrect input. Enter yes or no',
#                retries: int = 4):
#     while retries > 0:
#         answer = input(question).lower()
#         if answer == 'yes':
#             return 1
#         if answer == 'no':
#             return 0
#
#         retries -= 1
#         print(complaint)
#         print(f'Retries left: {retries}')
#
#
# write_down('Do you want exit?')
# print()
# write_down('Dell the file?', 'So exit or not?')
# print()
# write_down('Write down into file?', retries=2)



"""
Задача 2. Накопление значений
При работе со значениями по умолчанию и изменяемыми типами данных нужно знать и
остерегаться ещё одной интересной штуки.
Напишите функцию с двумя аргументами: первый — число num,
позиционный аргумент; второй — список lst, по умолчанию он пустой.
В теле функции в список добавляется число num и сам список выводится на экран.

В основной программе вызовите функции три раза только с одним аргументом (числом), например так:
add_num(5)
add_num(10)
add_num(15)
И посмотрите, что произойдёт.
После этого сделайте значение lst по умолчанию None и поправьте функцию,
чтобы она работала правильно.
"""


#
# def add_num(num, nums=None):
#     nums = nums or []
#     # хитрая конструкция, которая позволит упростить ввод:
#     # if not nums:
#     #    nums = []
#     # Первый вариант будет выбран, если nums не равен None, иначе будет создан и записан пустой список
#     nums.append(num)
#     print(nums)
#
#
# add_num(5)
# add_num(10)
# add_num(15)


"""
Задача 3. Помощь другу
Нашего друга попросили написать функцию, которая на вход принимает список всякого мусора. Ему нужно подготовить из этого списка список словарей, чтобы его коллеги смогли дальше продолжить обработку данных.
Вот список правил, что нужно сделать с изначальным списком:
Если в списке встретился словарь, то оставляем его.
Если в списке встретилась строка, то из неё нужно сделать словарь и положить его в итоговый список,
например  “abc” → {“abc”: “abc”}.
С числами нужно сделать то же самое, что и со строками.
Всё остальное выкидываем из нашего списка.

Друг написал программу, но в ней ошибка, так как она что-то не то выводит :(
Нужна ваша помощь, вот сама программа:

def create_dict(data, template=dict()):
    if isinstance(data, dict):
        return data

    if isinstance(data, int) or isinstance(data, float) or isinstance(data, str):
        return template[data] = data
 
def data_preparation(old_list):
    new_list = []
    for i_element in old_list:
        new_list.append(create_dict(i_element))
    return new_list
 
data = [“sad”, {“sds”: 23}, {43}, [12, 42, 1], 2323]
data = data_preparation(data)
print(data)

 

Исправьте программу и убедитесь, что всё работает верно.
"""

#
# def create_dict(data, template=None):
#     if isinstance(data, dict):
#         return data
#
#     if isinstance(data, (int, float, str)):
#         template = template or dict()
#         template[data] = data
#         return template
#
#
# def data_preparation(old_list):
#     new_list = []
#     for i_element in old_list:
#         new_elem = create_dict(i_element)
#         if new_elem:
#             new_list.append(new_elem)
#     return new_list
#
#
# data = ['sad', {'sds': 23}, {43}, [12, 42, 1], 2323]
# data = data_preparation(data)
# print(data)

****************************************
"""
Задача 1. Challenge-2
Вдохновившись мотивацией Антона, ваш друг тоже решил поставить перед собой задачу,
но не напрямую связанную с математикой, а именно:
написать функцию, которая выводит все числа от 1 до num без использования циклов.
Помогите другу реализовать такую функцию.
Пример работы программы
> Введите num: 10
> 1
> 2
> 3
> 4
> 5
> 6
> 7
> 8
> 9
> 10
"""


# def write_out_nums(num: int, help_num: int = 1) -> int:
#     if help_num == num:
#         return num
#     print(help_num)
#     help_num += 1
#     return write_out_nums(num, help_num)
#
#
# print(write_out_nums(12))


def print_n(n: int):
    if n == 0:
        return
    print_n(n - 1)
    print(n)

n = int(input())
print_n(n)




****************************************
